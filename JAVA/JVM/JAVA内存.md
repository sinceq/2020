# 				Java内存区域与内存溢出异常



## 一、运行时数据区域

### 程序计数器（Program Counter Register）

可以看作是当前线程所执行的字节码的行号指示器。

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

> 每条线程都需要有一个独立的程序计数器。

###  Java虚拟机栈（JVM Stack）

> 与程序计数器一样，VM Stack也是线程私有的，生命周期与线程相同。

VM Stack描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（**Stack Frame**）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

**局部变量表**：存放了编译期可知的各种Java虚拟机基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）。

> 在Java虚拟机规范中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

### 本地方法栈（Native Method Stacks)

> "A native method is a Java method whose implementation is provided by non-java code."

本地方法栈与VM Stack区别只是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

> 与VM Stack一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverFlowError和OutOfMemoryError异常

### Java堆（Java Heap)

Java堆是被**所有线程共享**的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。

> 分代收集理论

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出StackOverFlowError异常。

### 方法区（Method Area）

方法区与Java堆一样，是各个**线程共享**的内存区域，它**用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。**

跟进Java虚拟机规范的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

### 运行时常量（Runtime Constant Pool）

运行时常量是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量和符号饮用，这部分内容将在类加载后存放到方法区的运行时常量池中。

运行时常量池相对于Class文件常量池的另一个重要特征是具有动态性，Java语言并不要求常量一定只有编译器才能产生。

> // 运行期间也可以将新的常量放入池中
>
> String类的intern()方法。



### 直接内存（Direct Memory）

NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这快内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

> 动态扩展时会出现OutOfMemoryError异常

## 二、HotSpot虚拟机对象探秘

### 对象的创建

Java对象内存分配方式：

1. 指针碰撞（Bump The Pointer）

2. 空闲列表（Free List）

选择哪种分配方式由Java堆是否规整决定。而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。

对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，解决这个问题有两种可选方案：一种是对分配内存空间的动作进行同步处理（实际上虚拟机是采用**CAS**配上失败重试的方式保证更新操作的原子性）；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（**Thread Local Allocation Buffer, TLAB**）,哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。

### 对象的内存布局

在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

























